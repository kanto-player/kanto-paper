\documentclass{article}
\usepackage[latin1]{inputenc}
\usepackage[margin=1.0in]{geometry}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\setcounter{secnumdepth}{2}
\setcounter{equation}{0}

\title{Kanto Player \\
CSEE W4840 Final Report}
\author{
  Kavita Jain-Cocks\\
  \texttt{kj2264@columbia.edu}
  \and
  Howard Mao\\
  \texttt{zm2169@columbia.edu}
  \and
  Amrita Mazumdar\\
  \texttt{am3210@columbia.edu}
  \and
  Darien Nurse\\
  \texttt{don2102@columbia.edu}
  \and
  Jonathan Yu\\
  \texttt{jy2432@columbia.edu}
   \\}
 \date{\today}
\begin{document}

\maketitle
\newpage

\abstract{This project presents an audio player with frequency visualization. 
The user is able to play audio files from an SD card and view a nice visualization 
on a VGA display. We use a field-programmable gate array (FPGA) for implementation, 
with software handling user interaction and song coordination and hardware handling 
actual audio output and FFT visualization. }

\section{Introduction}

\section{System Architecture}

\subsection{High-Level Overview}
% include data path
% block diagram

\section{Design Implementation}
\subsection{FFT Unit}
The FFT unit is used to compute the discrete frequency transform of a set of audio
samples to be visualized. 

\subsubsection{Fast Fourier Transform Algorithm}
We use the basic Cooley-Tukey FFT algorithm with a radix of 16 to compute the
frequency transform of a given sample. The number of frequencies \(N\) computed by 
the FFT was chosen to be 256. The radix size and number of frequencies were chosen 
to optimize for space and time. The basic DFT is defined by the equation:

\begin{equation}
	X_k = \sum_{n=0}^{N-1} x_n e^{-\frac{2\pi j}{N} nk}
\end{equation}

where \(k\) and \(n\) are integers from 0 to \(N\). 

According to the Cooley-Tukey algorithm, 
we split our original input into 16 different parts and perform a DFT on each
individual component. We can then recombine the individual DFT outputs in 4
recombination stages, using the following equation for each stage: 

\begin{equation}
	X_k = \left\{
	\begin{matrix}
		E_k + e^{-\frac{2\pi j}{N}k} O_k		& 	\mbox{if } k < N/2 \\ 
		E_{k-N/2} - e^{-\frac{2\pi j}{N} (k-N/2)} O_{k-N/2} & 	\mbox{if }
		k \geq N/2. 
	\end{matrix} 
	\right.
\end{equation}

The resulting output is 256 frequency values.

\newpage

\subsubsection{Block Diagrams}

The FFT hardware consists of two types of pipelines, one for the DFT,
and another for the recombination. 

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{dft-unit}
	\caption{DFT Unit}
\end{figure}

The DFT pipeline computes a 16-point DFT according to equation 1. 

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{recombinator}
	\caption{Recombination Unit}
\end{figure}

The recombination unit computes 32 parts of the recombinational step 
according to equation 2. The upper and lower parts, \(X_k\) and 
\(X_{k + N / 2}\), are computed in parallel. This allows us to re-use the 
odd term \(e^{-\frac{2\pi j}{N}k} O_k\).

The complex multiplier in the recombination unit performs its computation
in two pipelined steps, as follows.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{complex-mult}
	\caption{Complex Multiplier}
\end{figure}

Our top-level FFT block uses two DFT units, a recombination unit,
two RAMs (one for time domain data and one for frequency domain data),
four ROMs for the recombination, one ROM for the DFT coefficients, and
a control unit to set all the multiplexers and control the flow of
computation.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{fft-top}
	\caption{FFT Top-Level}
\end{figure}

The DFT ROM holds 256 32-bit values, each one of which represents a
complex number (higher 16 bits for real part and lower 16 bits for
imaginary part). These values represent the constant coefficients
in the DFT equation \(e^{-\frac{2\pi j}{N} n k}\) as 16-bit fixed-point
precision numbers. Each value is addressed by an 8-bit address, where
the highest four bits represent the value of \(k\) and the lowest four bits
represent the value \(n\).

Similarly, the 4 recombination ROMs have 16, 32, 64, or 128 fixed point
imaginary values. These correspond to the constant coefficients
\(e^{-\frac{2\pi j}{N}k}\) from equation 2. The ROMs have 4-bit addresses, 
so only 16 values can be accessed during a single recombination step. 
For the larger ROMs, a select input set by the controller control which 
chunk of 16 values can be addressed.

The controller, in response to an external start signal, triggers
16 DFT computations, with 2 computations running in parallel at a time.
This is followed by 4 stages of recombination. Each recombination stage
uses a different ROM and consists of 8 steps (32 out of 256 outputs are
computed on each step).
	
\subsection{Audio Buffer}

\subsection{Visualizer} There are two main tasks that the vizualizer needs to accomplish.  The first is sequentially reading in the data produced by the FFT and the other is displaying that data on the vga.  Originally all 256 different frequencies were being displayed however after initial designs the decision made was to include data for the first 32 frequencies on the display since these are the hearable frequencies.  The reading process requires two states, a holding state and a reading state.  The transition to reading happens when the FFT sends a "done" signal which means that the data is in place to be read.  For display purposes, the 32 frequencies are placed into 16 bins, 2 per bin, each of which corresponds to one of sixteen bars located horizontally across the screen.  The height of these bars is decided by summing the amplitude of the two frequencies contained in the bin and then scaling this value to the necessary height for the screen.\\An additional functionality that was added was the ability to change color of the bars appearing on the screen.  Three switches correspond to red, green, and blue and allow the user to mix and match to create different colors.  The switches are active low so the default color when all switches are "off" is the white so as to be seen on the black background.  In order to improve the accuracy of the display adjustments were made so that new data is only read in when data is not being drawn to the screen.
  \includegraphics[width=20 cm]{viz_block_diagram.png}
% block diagram
% state diagram
% timing diagram
% test benches if available

\subsection{SD Card Controller}
	\subsubsection{SPI Protocol}
	\subsubsection{Block Diagram}
	

% block diagram
% state diagram
% timing diagram
% test benches if available

\subsection{Software User Interface}

\subsection{Miscellaneous Controller Components}
\subsubsection{The Conductor}
\subsubsection{Phase-Locked Loop for Multiple Clocks}
The visualizer unit and audio playback required different clocks to drive their respective peripherals, but also required clocks to synchronize communication with other modules in the kanto system. To most easily configure these clocks, a Phase-Locked Loop (PLL) was generated from an Altera Megafunction. The PLL was used to generate a 50MHz clock for general system synchronization, a 25MHz clock to drive the VGA display, and \textbf{something} for the audio output. %% NEED AUDIO CLOCK SPEED 44100/s? 

\section{Timeline \& Milestone Progress}
\begin{tabular}{cc|p{7cm}p{3cm}}
\textbf{Milestone} & \textbf{Date} & \textbf{Goal} & \textbf{Accomplished}\\ \hline
&&&\\
Milestone 1 & Apr 2 & RTL design and block diagrams of all peripherals.&
	\textit{Completed.}\\
&&&\\
Milestone 2 & Apr 16 & Individual peripherals written in VHDL and test benched.&
	\textit{Completed.}\\
&&&\\
Milestone 3 & Apr 30 & Build interfaces between all peripherals and finish synchronization software. &
	\textit{Completed}\\
&&&\\
Deadline&May 15&System complete and presentation finished.&\textit{Completed.}\\
&&&\\
\end{tabular}
%% should include software inclusion somewhere


\section{Contributions \& Teamwork}
	\begin{itemize}
	
	\item
	\textbf{Kavita Jain-Cocks}
		\begin{enumerate}
		\item item
		\item item
		\end{enumerate}
	
	\item 
	\textbf{Howard Mao}
		\begin{enumerate}
		\item item
		\item item
		\end{enumerate}
	
	\item 
	\textbf{Amrita Mazumdar}
		\begin{enumerate}
		\item item
		\item item
		\end{enumerate}
	
	\item 
	\textbf{Darien Nurse}
		\begin{enumerate}
		\item item
		\item item
		\end{enumerate}
	
	\item 
	\textbf{Jonathan Yu}
		\begin{enumerate}
		\item item
		\item item
		\end{enumerate}
	
	\end{itemize}

\section{Challenges \& Lessons Learned}

\section{Reflections \& Prospectus}
 
 \appendix
\section{Source Code}
 \subsection{VHDL}
 \subsection{C}
 \subsection{Python} %should we include python scripts to generate things? eh
 
\end{document}
